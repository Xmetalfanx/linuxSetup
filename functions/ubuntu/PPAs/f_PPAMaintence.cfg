function ppaBranchCheck()
{
    echo
    echo -e "Checking if your Ubuntu base is supported by selected PPA "

    # if the answer is no, should there be a variable ... say "ppaSupported"
    if [[ $supportedBases =~ $lsbCodename ]]; then
        echo "PPA works on the Ubuntu base you are on "
        PPASupported=yes
    
    #since this may not be ubuntu specific, this may not be a good idea

    # check 1 = "if lsbCodename is blank" ... I think anyway
    # check 2 = "if lsbCodename is not blank but is 'n/a' "
    elif  [ -z $lsbCodename ] || \
          [ $lsbCodename = "n/a" ]; then 
        echo -e "It appears you are not on Ubuntu"
    
    else 
        echo "PPA not made for the Ubuntu Base you are on"
        PPASupported=no
    fi 
    
}
########################################################################

function ppaPackageInstallCheck()
{
  if [ $ppaPackageInstall = 'yes' ]; then
  
    $install $packageNames
  
  elif [ $ppaPackageInstall = 'no' ]; then
    return
  #  really ... this else should never be reached 
  else
    echo -e "error detecting ppaPackageInstall variable status "
  fi

}

# This will check if the user wants to install the packages typically associated with the PPA (listed in each PPA function)
function ppaPackageInstallDefault()
{
    clear 
    echo -e "Would you like to install the packages associated with PPAs, by Default ?"
    echo
    echo -e "note: this DOES NOT mean ALL the packages in said-PPA, rather the most popular or most associated with said PPA "
    echo 
    read -p  "Your Choice? (Y/N):" installPPADefaultSelection

    case $installPPADefaultSelection in 

    [yY]|yes) ppaPackageInstall=yes 
      echo -e "Common/Popular packages associated with PPAs ${bold}will${completeReset}now be installed by default" 
       
      ;; 

    [nN]|no) ppaPackageInstall=no 
      echo -e "Common/Popular packages associated with PPAs will ${bold}NOT${completeReset} be installed by default" 
       
      ;; 

    # Catch all for everything else 
    *) echo -e "Invalid selection " 
        return ;; 

    esac 

    printf $ppaPackageInstall > $settingsDir/ubuntuPPA.txt

    echo
    echo "To change this setting, just run this menu item again and select, no, and packages will not be installed when PPAs are added" 
    echo
    userPrompt
    clear
    
}


# Asks if the user wants to install the software typically associated with the PPA in question 
function installPPAPackages()
{
  clear 
  echo -e "Would you like to install the packages typically associated with this PPA?"
  echo -e "Packages include: \t ${bold}$packageNames${completeReset}"
  echo 
  read -p   "Your Choice?(Y/N):" installPPASelection

  case $installPPASelection in 

  [yY]|yes) 
      # echo = for debugging for now 
      echo -e "This would install $packageNames on your system"
      
      # $install $packageNames 
      
      ;; 

  # should NOT exit the scripts as a whole 
  [nN]|no) 
    # echo only for debugging 
    echo "You have chosen NOT to install $packageNames" ;; 
  
  *) echo -e "Invalid selection " 

  return ;; 

  esac 


}

# Meta function for adding PPAs 
function addPPA()
{
    
    # call to function in /functions/ubuntu/PPAs/f_branchCheck.cfg 
    # check if PPA is supported by the current version of Ubuntu running 
    ppaBranchCheck

    case $PPASupported in 

    yes) 
      echo -e "Adding $PPAName PPA"
      sudo apt-add-repository $ppaSource
      ;;

    # This SHOULD NOT exit the scripts completely, just back to the main menus 
    *) exit ;; 

    esac  
    ## ends the case if the PPA is supported 

  # Refreshes the repo 
  $refresh


  # possibly install packages based on var
  # Default = not installing software but i will have the user decide that
  
  # Issue i see = I do want to set "no" as a default but i need a way to store the answer (in case the user changes it )
  # in a file and read that file in on startup ... only changing the default back to no if the file doesn't exist or something... 
  # i do not want to overwrite the user's choice
  ppaPackageInstallCheck

}