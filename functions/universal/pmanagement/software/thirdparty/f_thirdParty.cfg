# ? - I may need to add the f_deb.cfg include here ... 
# ? - maybe f_thirdparty.cfg too ... just remember this in case things go wonky 


function strip_download_file_info() {

	# August 2025: not sure this NEXT var is needed now 
	# programBasename=$(basename "${programURL}")

	# this say could be an AppImage or a tar.gz file (just examples)
 	fileNameWEXT=$(basename ${programURL} )

	# July 2023: THIS SEEMS like exactly what Apt would need.
		# note to self: issue apt cant take URLs
 	downloaded_file="${downloadDir}/${fileNameWEXT}"
	
}

function check_downloaded_file_size() {
	# Check if file size is zero; if so, delete it and continue as if it doesn't exist

	if [ ! -s "${downloadedFile}" ]; then
		fancy_message warning "File ${downloadedFile} exists but is zero size. Deleting and re-downloading."
		rm -f "${downloadedFile}"
	fi 
}


# is this a bad function name considering (for now) i have a file with the sane name
## ?? or is that "downloaded_file" ?? 
function download_file() {

	# the idea is some functions need this info.. like the apt DEB install function
	strip_download_file_info 


	echo "Downloading File"

	# TODO: come back to integrity checking later 	
	

	if [ $(echo ${programURL} | grep -o "...$") == "git" ]; then
		fancy_message action "Detected .git URL, cloning repo for ${programName}"
		git clone ${programURL}
		return 0
	else
		# if not a .git URL, the download file check should be done here

		fancy_message action "About to download ${programURL} to ${downloadDir}"

		# download ${programURL} to directory/folder ${downloadDir}
		wget ${programURL} -P ${downloadDir}

		# instead of just displaying downloaded message can i check to see if the above step didn't 
		# stop with an error (so to speak)
	fi
}




##################################################################
# Meta Function
# ? 2025: I need to rethink this function... i am refactoring things ...
# ? i need to figure out what is needed and what isn't


# i think i SHOULDN'T pass debs directly to gdebiInstall but to here instead
# the idea is consistancy 


# TODO: Document what is needed to be passed, here 
function metaExternalDownload() {

	
	# idea ... i FORGOT how i did it but i think i figured out how to get direct links from github "release" pages ... 
	# in some cases i dont want to clone the repo but in those cases i THINK the programURL would be say "https://github/Foo/Bar/releases/latest/" or something like that and despite being 
	# from Github, it wouldn't end in .git 


	# function call to download the file or (if .git at the end) git clone the repo
	download_file





	## Handle downloaded file
	handleDownloaded ${extonly} ${fileNameWEXT}

	#unsetVars

	# TODO: cleanup code (removing archive file or say RPM or DEB) should be here

}

# from deb-apt ( https://github.com/wimpysworld/deb-get )
	# ** credit for this goes to them
# this should help me get some URLs like on Sourceforge, I beleive
# this should take a URL as an arguement
function unpackURL() {

  # -w: Make curl display information on stdout after a completed transfer.
  # -I: Fetch the headers only
  # -L: (HTTP) If the server reports that the requested page has moved to a different location
    # (indicated with a Location: header and a 3XX response code), this option will make curl redo the
    # request on the new place.
  # -s: Silent or quiet mode. Don't show progress meter or error messages.  Makes Curl mute
  # -S: When used with -s, --silent, it makes curl show an error message if it fails.

  #clear
  #echo -e "debugging\n\nUnpacking URL "
  curl -w "%{url_effective}\n" -I -L -s "${1}" -o /dev/null
}

##########################################################################

# idea: just assign file_type here 
function determine_downloaded_file_types() {

	# idea/note to self:  determine MIME/file type here 
    case "${mime_type}" in
        application/x-debian-package) fancy_message action "Detected DEB package" && file_type="deb" ;;
        application/x-rpm) fancy_message action "Detected RPM package" && file_type="rpm" ;;
        application/zip) fancy_message action "Detected ZIP archive" && file_type="zip" ;;
        application/x-executable|application/x-iso9660-appimage) 
			fancy_message action "Detected AppImage" &&  file_type="appimage" ;;
        application/x-gzip|application/gzip)
            fancy_message action "Detected tar.gz archive"
			file_type="tar" ;;
        application/x-bzip2)
            fancy_message action "Detected tar.bz2 archive"
			file_type="tar" ;;
        application/x-xz)
            fancy_message action "Detected tar.xz archive"
			file_type="tar" ;;
        application/x-tar)
            fancy_message action "Detected tar archive"
			file_type="tar" ;;
        *)
            fancy_message info "Unknown or unhandled MIME type: ${mime_type}"
            ;;
    esac

	#! i see a potential issue ... so many tar files detected as "tar"... how do i know (so to speak)
	#! how to extract things?


}

# I need to have the file downloaded before this function is called
# Checks the MIME type of the downloaded file and takes appropriate action
function check_file_mime_type() {
	# ?? if the file doesn't exist, would it even get to this point?
	# ?? if that is the case, there is no point to the if statement directly below 
    if [ ! -f "${downloadedFile}" ]; then
        fancy_message error "File ${downloadedFile} does not exist"
        return 1
    fi


	# Uses file -i to get the MIME type of the downloaded file
    mime_type=$(file -i "${downloadedFile}" | awk '{print $2}' | cut -d';' -f1)



	determine_downloaded_file_types



	# idea/note to self:  the MIME/file type is known here... this is where to set things up and call things
	case ${file_type} in 

		deb) aptInstallDEB  ;;
		rpm) $install "${downloadedFile}"  ;;
		zip) unzip "${downloadedFile}" -d "$programName"  ;;	
		appimage)		
			appimage_final_location="/home/$USER/Applications/"
			
			appImageExecutable "${downloadedFile}"
			
			echo -e "Moving ${programTitle} AppImage to ${appimage_final_location}"
			cp "${downloadedFile}" "${appimage_final_location}"
			;;

		tar) 
			# check to see if finalProgramLocation exists (IT SHOULD at this point)
			[ -d "${finalProgramLocation}" ] && echo -e "${finalProgramLocation} location does exist"  || echo -e "${finalProgramLocation} does not exit"
			;; 
	esac 


	handle_tar_archives
	
}
