

###################################################################################
## Gdebi related

# this should get a URL passed to it
function gdebiInstall() {

    # checks for gdebi and installs it if needed
    clear
    fancy_message action "Checking for Gdebi for the install"
    installApp "gdebi"
    userPrompt

	# only downloads the DEB if not already downloaded
		# i can see an issue with broken downloads (say "foobar.deb" is downloaded but is 0 bytes... not sure how i can check that vs the known file sie )
    if [ ! -f ${downloadedProgramFile} ]; then
		fancy_message action "Downloading ${programTitle} DEB file"
		wget -P ${downloadDir} ${programURL}
    	#debugging prompt
		#userPrompt
	else
		echo "${programTitle} DEB already downloaded"
	fi


    fancy_message action "Installing ${programTitle}"
    sudo gdebi ${downloadedProgramFile}

    userPrompt

    # idea to clear the var
    # why is this here? ...
    ## it maybe needed here but i just dont remember why i put it here specifically
    packageName=/dev/null

}
## End Gdebi related
###################################################################################



###############################################################
# Test Output Functions
function stripFileInfoTestOutput() {
	clear
	# Display Test for the full URL
	echo -e "\n\nFull URL is:\t $programURL"
	# Display Test for Total file Extension
	echo -e "fileNameWEXT is:\t $fileNameWEXT"
	echo
	###############################################

	userPrompt
}


function fileExtOutput() {
	#####################################
	clear
	echo -e "completeExt3: $completeExt3"
	echo -e "completeExt6: $completeExt6"

	# only for appImage
	echo -e "completeExt8 : $completeExt8"

	userPrompt
	######################################

}

# End of Test Output functions
###############################################################################


# The reason this function is so complicated is so it handles DEBs, RPMs AND various "Tarballs" all with not only different extentions but different lengths of said-extension
function stripFileInfo() {
	# this say could be an AppImage or a tar.gz file (just examples)
	fileNameWEXT=$(basename ${programURL} )

	downloadedFile="${downloadDir}/${fileNameWEXT}"

	# issue: say tiny media manager and "tmm.3.4.4.5.tar.gz" ... matching the first period will not get the file ext 
	fileEXT=${fileNameWEXT##*.}


	# i dont like this ... i want to check if "tar" IS there 
	[ "${fileEXT}" = "gz" ] && fileEXT="tar.gz"
	[ "${fileEXT}" = "xz" ] && fileEXT="tar.xz"
	[ "${fileEXT}" = "bzip2" ] && fileEXT="tar.bzip2"
	
	# for debugging
	#fileExtOutput

}

function downloadFile() {

    # note to self: DEBs or RPM's wouldn't make it here.  Nov 2022: what controls that though?
	# RPMs too? ... but the following step (HandleDownloaded) needs a RPM ..what did i do

    # IF the file ALREADY exists, nothing should be done ...
    # meaning dont download the file again
    if [ -f "${downloadedProgramFile}" ]; then
		fancy_message info "File ${downloadedProgramFile}, already downloaded"
		userPrompt
    else
        case $fileEXT in
        	git)
            	# note to self: this here is for .git downloads only ...
				# do not confuse this with extensions below downloaded FROM github
				git clone ${programURL}
				;;

        	rpm|tar.gz|tgz|tar.bz2|zip|AppImage)
            	userPrompt
            	fancy_message action "Downloading ${programTitle}"
            	wget -P ${downloadDir} ${programURL}
            	fancy_message info "${fileNameWEXT} downloaded "

	            ;;

        esac
    fi
}
################################################################
# Cleanup functions 

function cleanupDownloadedFile() {
    fancy_message action "Cleaning up Downloaded File"
    rm ${$downloadedFile}
}

function unsetVars() {
	unset ${programName} ${programTitle} $[programHomepage] $[programURL]
}

# End of Cleanup functions 
##################################################################

function handleDownloaded_CheckExtractedFolder() {
	
	extractedDownloadDir="${downloadDir}/${programName}"

	# check for extracted download dir
	case ${fileEXT} in
		tar|tar.bz2|tar.gz|tar.xz|tgz)
			fancy_message action "Checking for ${extractedDownloadDir} directory"

			if [ ! -d "${extractedDownloadDir}" ]; then
				fancy_message info "Making Directory ${extractedDownloadDir}" && mkdir $extractedDownloadDir
			else
				fancy_message info "Directory ${extractedDownloadDir} already exists"
			fi
	esac

	userPrompt
}

# handles downloaded files after downloaded
function handleDownloaded() {

	fancy_message action "\nExtracting/Installing $fileNameWEXT"

	# checks for extracted folder and creates it if it doesn't exist, for some file types 
	handleDownloaded_CheckExtractedFolder

	# non-tar related files 
	case ${fileEXT} in
		deb)
			# i need to pass a URL to gdebiInstall
			gdebiInstall "${programURL}"
			;;

		rpm) $install "${downloadedProgramFile}" ;;
		zip) unzip ${downloadedFile} -d "$programName" ;;
		AppImage)
			# March 2023 idea
			programFile="AppImage"

			# Lets user decide if they want to set it as executable
			appImageExecutable ${downloadedFile}

			# this moves the AppImage to ~/Program/$programTitle and adds it to the user's menus
			setupExtractedApps
			;;

	esac 

	# "if fileEXT contains 'tar' should be here 
	
	if [[ "${fileEXT}" == *"tar"* ]]; then 
		clear
		echo -e "debugging: a tar related file detected"

		# debugging check to eee if extractedDownloadDir exists (IT SHOULD at this point) 
		[ -d "${extractedDownloadDir}" ] && echo -e "${extractedDownloadDir} location does exist"  || echo -e "${extractedDownloadDir} does not exit"

		# tar related 
		case ${fileEXT} in
			tar.bz2) tar -jxvf ${downloadedFile} -C "$extractedDownloadDir" ;;
			tar.gz|tgz) tar -zxvf ${downloadedFile} -C "${extractedDownloadDir}" ;;
			tar) tar -xvf ${downloadedFile} -C "${extractedDownloadDir}" ;;
			tar.xz) tar -xf ${downloadedFile} -C "${extractedDownloadDir}" ;;
			*)
				fancy_message info "Problem extracting/installing ${programTitle} "
				userPrompt ;;

		esac

	fi 

	#cleanupDownloadedFile

}


##################################################################
# Meta Function
# takes ${programTitle} ${programURL} (in that order) as arguments


# i think i SHOULDN'T pass debs directly to gdebiInstall but to here instead ... at the top of this function it
# should sort out DEB and RPM files
function metaExternalDownload() {

	programBasename=$(basename "${programURL}")

	# Get info from the URL
	stripFileInfo ${programURL}

	# this needs to be here (not in f_variables) since $fileNameWEXT is not known there
	downloadedProgramFile="${downloadDir}/${fileNameWEXT}"

	# if the extension is DEB or RPM (where is the RPM code?)
	# idea: this here so i can still get the info via the URL in the stripFileInfo function
	case ${fileFormat} in
		deb)
			# getdebiInstall - A) checks for and installs (what if someone just wants to use dpkg -i? ... am i not K I S S here thinking of that?) gdebi, B) downloads the DEB file, C) uses gdebi to install said file (I think i choose gdebi since dpkg doesn't handle dependencies as good, ... I swear it was something like )
			gdebiInstall ${programURL}
			# where does this return to? if just say outside of this case statement below, then downloadFile and the rest run for no reason and i dont want that
			return ;;
	esac

	# output fuction to show what stripFileInfo found
		# used for debugging and should be commented out by default
	#stripFileInfoTestOutput

	## Download file to ~/Downloads
		# in theory, DEB files wouldn't get here
	downloadFile ${programName} ${programURL}

	## Handle downloaded file
		## Extract if an archive
	handleDownloaded $extonly $fileNameWEXT

	# March 2023 idea
	#unsetVars
	
	# cleanup code (removing archive file or say RPM or DEB) should be here

}

# from deb-apt ( https://github.com/wimpysworld/deb-get )
# credit for this goes to them
# this should help me get some URLs like on Sourceforge, I beleive
# this should take a URL as an arguement
function unpackURL() {

  # -w: Make curl display information on stdout after a completed transfer.
  # -I: Fetch the headers only
  # -L: (HTTP) If the server reports that the requested page has moved to a different location
    # (indicated with a Location: header and a 3XX response code), this option will make curl redo the
    # request on the new place.
  # -s: Silent or quiet mode. Don't show progress meter or error messages.  Makes Curl mute
  # -S: When used with -s, --silent, it makes curl show an error message if it fails.

  #clear
  #echo -e "debugging\n\nUnpacking URL "
  curl -w "%{url_effective}\n" -I -L -s "${1}" -o /dev/null
}