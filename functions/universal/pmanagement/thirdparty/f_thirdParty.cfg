
## This entire function is for testing only
function stripFileInfoTestOutput
{

  clear
  # Display Test for the full URL
  echo -e "\n\nFull URL is:\t $packageURL"
  ###########################################


  # Display Test for Total file Extension
  echo -e "\nTotal fileName is:\t $fileNameWEXT"
  ###############################################


  ## Display Test for final output
  echo -e "Final Extension for test loop:\t $extonly"

  echo -e "fileName by itself: \t $fileName"
  ###########################################

  userPrompt
}
###########################################################

# The reason this function is so complicated is so it handles DEBs, RPMs AND various "Tarballs" all with not only different extentions but different lengths of said-extension 
function stripFileInfo()
{
  #####################################
  # for debugging
  clear
  echo -e "Inside stripFileInfo function"
  echo -e "$1: " $1
  echo -e "$2: " $2
  userPrompt
  #################################
  
  
  # $1 (HERE) is a URL ....
    # whatever the $2 (to the meta function that calls this) var was that got passed, was assigned to packageURL in the metaExternalDownload function that called this

  # fileName with extension
  ## Idea: "match longest match to anything up to the / (which / ?.... )"
  fileNameWEXT=${packageURL##*/}

  # fileName by itself, NO extention
  ## "the longest match until there is a period".... so this will match untiL THE FINAL period it finds
  fileName=${fileNameWEXT%%.*}

  completeExt4=${fileNameWEXT:(-4)}
  completeExt7=${fileNameWEXT:(-7)}
  completeExt9=${fileNameWEXT:(-9)}


  if  [ "$completeExt7" = ".tar.gz" ] || \
      [ "$completeExt7" = ".tar.bz2" ] || \
      [ "$completeExt7" = ".tar.xz" ]; then

      extonly=$completeExt7

  elif [ "$completeExt9" = ".AppImage" ]; then
      extonly=$completeExt9

  elif  [ "$completeExt4" = ".deb" ] || \
        [ "$completeExt4" = ".rpm" ] || \
        [ "$completeExt4" = ".zip" ] || \
        [ "$completeExt4" = ".tgz" ]; then

      extonly=$completeExt4

  else
    echo -e "error detecting file extension of file to download"

  fi

  ######################################
  # Call to test output function
  # This will be removed later
  #stripFileInfoTestOutput
  userPrompt
  ########################################

}

###############################################################################

## IF the file ALREADY exists, nothing should be done ... or at least that is the idea 
function downloadFile()
{
    # change the pwd (present working directory)
    cd ~/Downloads

    # Make Directory
    #mkdir $fileName

    # Enter Directory
    #cd $fileName

    
    ## Wait a econd ... how does this make sense as the meta function? .. .I'd need to know $fileNameWExt first 
    if [ -f $fileNameWEXT ]; then

      # Do nothing, since file is already downloaded
      echo -e "File $fileNameWEXT, already downloaded"
      return

    else

        case $extonly in

        .git)
            #idea: remove this and pass this to a git function instead
            git clone $packageURL
            ;;

        .tar.gz|.tgz|.tar.bz2|.deb|.rpm|.zip|.AppImage)

            wget $packageURL

            echo $fileNameWEXT " downloaded "

            ;;
        esac

    fi

}

###############################################################################################

function handleDownloaded()
{

    echo -e "Extracting/Installing $fileNameWEXT"

    mkdir $fileName

    case $extonly in

      .deb) sudo dpkg -i $fileNameWEXT ;;

      .rpm) $install $fileNameWEXT ;;

      .tar.bz2)  tar -C $fileName -xJf $fileNameWEXT ;;

      .tar.gz|.tgz)
        # I SHOULD have it make a temp location before extracting so the extracted downloads are organized in one place and not say ... in the root dir of these scripts
        tar -C $fileName -zxvf $fileNameWEXT 
        customMenuItemMenu
        ;;

      .tar) tar -C $fileName -xvf $fileNameWEXT ;;

      .tar.xz)
          ## This echo is a "note to self" i think
          tar -C $fileName -xf $fileNameWEXT ;;

      .zip)
        # unzips to the user's Downloads folder
        # idea: unzip $1 to LOCATION $1
        unzip $fileNameWEXT -d $fileName ;;

      .AppImage)

        appImageExecutable $fileNameWEXT ;;

      *)
          echo -e "Problem extracting/installing $1 "
          userPrompt ;;

    esac

}

function moveThirdPartyAppForMenu
{
  # This probably should be called by the createMenu function

  # I need to know the subfolder name in ~/Downloads
  # I need to take that and move it to /usr/local/bin

    echo
    echo -e "Moving $fileNameWEXT to /usr/local/bin"
    
    ## For testing only 
    userPrompt

    # mv $fileNameWEXT /usr/local/bin

    ######################################
    # Test
    ls /usr/local/bin
    userPrompt
    ##############


}

##################################################################
#################################################################

## Meta Function
function metaExternalDownload()
{
    # $1 = progName
    # $2 = downloadURL (<~ not an actual var name, but a description )

    ########################################################################
    # Debugging code only 
    echo  -e "In metaExternalDownload function "
    echo "1: $1"
    echo "2: $2"
    userPrompt
    ########################################################################

    # idea: assign $packageURL (whatever get's passed as the second arguement to $packageURL here )
    packageURL=$2

    # Get info from the URL
    stripFileInfo $packageURL

    ## Download file to ~/Downloads
    downloadFile $progName $packageURL

    ## Handle downloaded file
      ## Extract if an archive
      ## install if DEB or RPM

    handleDownloaded $extonly $fileNameWEXT

}

