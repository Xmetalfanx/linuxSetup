###################################################################################
## Gdebi related 

function checkGdebi() {
    clear
    echo -e "Checking for Gdebi for the install"

    # checks and installs if it not already installed
    installApp "gdebi"

}

# may 9, 2022: only used atm for two wine related deps .... is that a reason to keep this function?
function gdebiInstall()
{
    # checks for gdebi and installs it if needed
    checkGdebi

    clear

    ## use $1 for now (vs something more descriptive )
    packageName=$(basename $1)

    # Change PWD
    cd ~/Downloads


	  wget $1


    userPrompt
    echo -e "Installing $packageName"

    sudo gdebi $packageName

    userPrompt

    # idea to clear the var
    packageName=/dev/null

}
## End Gdebi related 
###################################################################################

###################################################################################
## Start of functions for third party extraction to Programs folder 


# what gets passed?
  # I need to know 
    # the menu file name  $menuFile
    # the icon file name  $iconFile 
function setPathVars()
{
  # ??? can i move this to f_variables.cfg?
  fullProgramPath=$(find ~+ -type f -name "$programFile" )
  programPath=$(basename $fullProgramPath )
  execPath=$(echo -e "Exec=$fullProgramPath" )
  
  # issue is some are pngs and others are svgs (i'd like all svgs )
    # this is why i didn't put the extension on the last part below 
  iconPath="$xmetalScriptsRoot/menu/$programName"  
    
}

fuction debuggingVars() {
  echo -e "fullProgramPath:\t $fullProgramPath"
  echo -e "programPath:\t$programPath"
  echo -e "execPath:\t $execPath"
  echo -e "iconPath:\t $iconPath"
}


function populateMenuFile() {

  echo "Adding Exec= line, to menu file"
  # where am i doing this?  shouldn't this be moved somewhere first? 
  echo -e $execPath >> $menuFile
  
}


function programsDestinationDetection()
{
    # Check if ~/Programs exists, and if not, create it
    if [ -d $programDir ]; then
        echo -e "$programDir already exists"
    else
        echo -e "$programDir does not already exist, creating directory to store third party apps"
        mkdir $programDir
        echo -e "Program directory create.  The location is in your user's Home folder as \"Programs\" "

    fi

    ################################################################################################
    # Subdirectory/SubFolder check

    # If the subfolder does not exist, create it
    if [ ! -d "$programDir/$programName" ]; then
            echo -e "$programDir/$programName does not exist"

            # Create the directory
            mkdir $programDir/$programName

    elif [ ! -z "$(ls -A $programDir/$programName)" ]; then
        echo -e "$programDir/$programName is not empty"

        ## can not remember my intent for what happened here

    fi

}

# WHAT IS THE POINT of this being a seperate function? 
function moveAppImageToProgramsFolder()
{
	echo -e "Moving $programTitle AppImage to ~/Programs/ folder"
	
	mv $fileNameWEXT $programDir/$programName

	echo -e "Copying Icon file over for menu"
	cp $xmetalScriptsRoot/menu/$iconFile $programDir/$programName

}


# function to move third party app (tarballs, not really debs or rpm files) to a "Programs" folder
function moveToProgramsFolder()
{
    clear

    # Checks for the destination and if what is needed is there
      # if not .... set it up
    programsDestinationDetection

    case $extonly in
      AppImage) moveAppImageToProgramsFolder ;;

      *)
      
        programDirLocation="$programDir/$programName"
    
        echo -e "Moving $programName/ to $programDir"
        # what is the pwd, here? 
        echo -e "debugging:\tpwd:\t $pwd"
      
        cp -r $programName $programDirLocation/

        echo -e "Copying Icon file over for menu"
        cp $xmetalScriptsRoot/menu/$iconFile $programDirLocation

      ;;

    esac
}

# this is for apps that can run if you just extract them... a sort of meta function i guess

# think of better functio name later
function extractedApp() {

    moveToProgramsFolder
    
    setPathVars
    
    debuggingVars
    

    #customMenuItemChoice

}

## End of functions for third party extraction to Programs folder 
##############################################################################################



##########################################################################################



# This entire function is for testing only
function stripFileInfoTestOutput()
{

	clear
	# Display Test for the full URL
	echo -e "\n\nFull URL is:\t $packageURL"
	# Display Test for Total file Extension
	echo -e "fileNameWEXT is:\t $fileNameWEXT"
	echo
	###############################################

	## Display Test for final output
	echo -e "fileNameFullNoDots: $fileNameFullNoDots"

	echo -e "extonly:\t $extonly"
	echo
	echo -e "archiveName by itself: \t $archiveName"
	###########################################

	userPrompt
}
###########################################################

function fileExtOutput()
{
	#####################################
	clear
	echo -e "completeExt3: $completeExt3"
	echo -e "completeExt6: $completeExt6"

	# only for appImage
	echo -e "completeExt8 : $completeExt8"

	userPrompt
	######################################

}
###############################################################################


# The reason this function is so complicated is so it handles DEBs, RPMs AND various "Tarballs" all with not only different extentions but different lengths of said-extension
function stripFileInfo()
{
	#fileNameWEXT=${packageURL##*/}
	fileNameWEXT=$(basename $packageURL)

	#fileNameWEXT with .'s stripped out
	fileNameFullNoDots=$(echo $fileNameWEXT | tr -d \.)

	## These numbers are not right for my stripped test .. the number counts the .'s
	completeExt3=${fileNameFullNoDots:(-3)}
	completeExt5=${fileNameFullNoDots:(-5)}
	completeExt6=${fileNameFullNoDots:(-6)}
	completeExt8=${fileNameFullNoDots:(-8)}

	#fileExtOutput

	if  [ "$completeExt5" = "targz" ] || \
		[ "$completeExt5" = "tarxz" ]; then

		extonly=$completeExt5

	elif [ "$completeExt6" = "tarbz2" ]; then
		extonly=$completeExt6

	elif [ "$completeExt8" = "AppImage" ]; then
		extonly=$completeExt8

	elif  [ "$completeExt3" = "deb" ] || \
			[ "$completeExt3" = "rpm" ] || \
			[ "$completeExt3" = "zip" ] || \
			[ "$completeExt3" = "tgz" ]; then

		extonly=$completeExt3

	else
		echo -e "error detecting file extension of file to download"

	fi

		# fileName by itself, NO extention
	## "the longest match until there is a period".... so this will match untiL THE FINAL period it finds
	archiveName=${fileNameFullNoDots%$extonly}


}

function downloadFile()
{
    extractedDownloadLocation="$downloadDir/$programName"

    
    # may 2022 - do i need this  if i can just wget to the ne wvar extractedDownloadLocation ?? 
    cd $downloadPath

    # IF the file ALREADY exists, nothing should be done ... or at least that is the idea
    if [ -f $fileNameWEXT ]; then

      # Do nothing, since file is already downloaded
      echo -e "File $fileNameWEXT, already downloaded"
      
      echo -e "debugging userPrompt"
      userPrompt
      
      return
      

    else

        case $extonly in

          git)
              #idea: remove this and pass this to a git function instead
              git clone $packageURL
              ;;
  
          targz|tgz|tarbz2|deb|rpm|zip|AppImage)
  
              echo -e "Downloading $programTitle"
              wget $packageURL
  
              echo $fileNameWEXT " downloaded "
  
              ;;
        esac
    fi
}

function handleDownloaded()
{
    #clear

    #handleDownloadedOutputTest
    echo -e "\nExtracting/Installing $fileNameWEXT"

    # maybe switch the deb option to gdebi (with check) but see what may break (if anything) first
    # WAIT ... keep the other gdebiInstall function and pass to that from here? ... good idea?

    case $extonly in

      deb)
        checkGdebi
        sudo gdebi $fileNameWEXT
         ;;

      rpm) $install $fileNameWEXT ;;

      tarbz2) tar -jxvf $fileNameWEXT --one-top-level=$programName ;;
      targz|tgz)  tar -zxvf $fileNameWEXT --one-top-level=$programName ;;
      tar) tar -xvf $fileNameWEXT --one-top-level=$programName ;;

      tarxz)
          ## This echo is a "note to self" i think
          tar -xf $fileNameWEXT --one-top-level=$programName ;;

      zip)
        # unzips to the user's Downloads folder
        # idea: unzip $1 to LOCATION $1
        unzip $fileNameWEXT -d $fileName ;;

      AppImage)

        # Lets user decide if they want to set it as executable
        appImageExecutable $fileNameWEXT ;;

      *)
          echo -e "Problem extracting/installing $1 "
          userPrompt ;;

    esac
    
    
    # NOTE TO SELF: i should still be in /Downloads at this point 
    userPrompt
    

    echo -e "Cleaning up Downloaded File"
    rm $fileNameWEXT
}


##################################################################

## Meta Function
function metaExternalDownload()
{

    # Get info from the URL
    stripFileInfo $packageURL

    #stripFileInfoTestOutput

    ## Download file to ~/Downloads
    downloadFile $programName $packageURL

   ## Handle downloaded file
      ## Extract if an archive
      ## install if DEB or RPM

    handleDownloaded $extonly $fileNameWEXT

}

