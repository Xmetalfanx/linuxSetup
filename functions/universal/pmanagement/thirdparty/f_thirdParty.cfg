
## This entire function is for testing only 
function stripFileInfoTestOutput
{
 
  clear
  # Display Test for the full URL
  echo -e "\n\nFull URL is:\t $packageURL"
  ###########################################


  # Display Test for Total file Extension
  echo -e "\nTotal fileName is:\t $fileNameWEXT"
  ###############################################


  ## Display Test for final output
  echo -e "Final Extension for test loop:\t $extonly"

  echo -e "fileName by itself: \t $fileName"
  ###########################################
}
###########################################################
###########################################################


## Gets info from URL to be used later 
function stripFileInfo()
{
  
  # $1 is a URL 

  # fileName with extension 
  ## Idea: "match longest match to anything up to the / (which / ?.... )" 
  fileNameWEXT=${packageURL##*/}

  # fileName by itself, NO extention 
  ## "the longest match until there is a period".... so this will match untiL THE FINAL period it finds 
  fileName=${fileNameWEXT%%.*}

  completeExt4=${fileNameWEXT:(-4)}
  completeExt7=${fileNameWEXT:(-7)}

  # I forgot if the period should be there or not 
  if  [ "$completeExt7" = ".tar.gz" ] || \
      [ "$completeExt7" = ".tar.bz2" ] || \
      [ "$completeExt7" = ".tar.xz" ]; then 
    
      extonly=$completeExt7

  # Todo: fill this out later
  elif  [ "$completeExt4" = ".deb" ] || \
        [ "$completeExt4" = ".rpm" ] || \
        [ "$completeExt4" = ".zip" ] || [ "$completeExt4" = ".tgz" ]; then
      
      extonly=$completeExt4
  
  else
    echo "error detecting file extension of file to download"


  fi

  ## Leave this here for now for future testing ... remove/comment out, later 
  #echo -e "extonly: " $extonly

  ######################################
  # Call to test output function 
  # This will be removed later 
  # stripFileInfoTestOutput
  ########################################

  userPrompt
  
}

###############################################################################

## This is should be what is called from program functions 
function downloadFile()
{
    # change the pwd (present working directory)
    cd ~/Downloads

    # Make Directory
    mkdir $fileName

    # Enter Directory
    cd $fileName


    if [ -f $fileNameWEXT ]; then
    
      # Do nothing, since file is already downloaded
      return 
      
    else 

        case $extonly in 

        .git) 
            #idea: remove this and pass this to a git function instead 
            git clone $packageURL
            ;; 

        .tar.gz|.tgz|.tar.bz2|.deb|.rpm|.zip)

              wget $packageURL
          
            echo $fileNameWEXT " downloaded "

            ;; 
        esac 

    fi 

}

###############################################################################################

function handleDownloaded()
{
    
    echo -e "Extracting/Installing $fileNameWEXT"
    
    ###################################
    # testing only 
    #echo -e "Extonly: $extonly"
    #echo -e "fileNameWEXT: $fileNameWEXT"
    #userPrompt
    ######################################

    # no clue if this is needed or if it'd help 
    mkdir $fileName

    case $extonly in 

      .deb) sudo dpkg -i $fileNameWEXT ;; 

      .rpm) $install $fileNameWEXT ;;

      .tar.bz2)  tar -C $fileName -xJf $fileNameWEXT ;; 

      .tar.gz|.tgz) 
        # I SHOULD have it make a temp location before extracting so the extracted downloads are organized in one place and not say ... in the root dir of these scripts 
        tar -C $fileName -zxvf $fileNameWEXT ;;

      .tar) tar -C $fileName -xvf $fileNameWEXT ;;

      .tar.xz) 
          ## This echo is a "note to self" i think
          tar -C $fileName -xf $fileNameWEXT ;; 

      .zip) 
        # unzips to the user's Downloads folder
        # idea: unzip $1 to LOCATION $1
        unzip $fileNameWEXT -d $fileName ;; 
      
      *) 
          echo -e "Problem extracting/installing $1 "
          userPrompt ;; 

    esac 

}

##################################################################
#################################################################

## Meta Function 
function externalDownload()
{
    # $1 = Program Name (progName)
    # $2 = URL (programURL)

    # Get info from the URL 
    stripFileInfo $programName $packageURL

    ## Download file to ~/Downloads
    downloadFile $programName $packageURL

    ## Handle downloaded file
      ## Extract if an archive 
      ## install if DEB or RPM 
    
    handleDownloaded $extonly $fileNameWEXT

}


#################################################################
# Start of Universal third party repo section

## RPM Fusion for Fedora 
## Packman for OpenSuse 



function thirdPartyRepoCheck()
{
  # IF they exist 
  # Opensuse has pacman installed 
  # Fedora has RPMFusion installed


  case $distroBase in 

  fedora) 
      if  [ -z "$(dnf repolist | grep rpmfusion)" ]; then 

            echo -e "Extra Repos already enabled"
            return

      else 
          # Install third party repo 
          universalExtraRepos

      fi 

      ;; 

  opensuse) 

      if [ -z "$(zypper lr | grep packman)" ]; then 

            echo -e "Extra Repos already enabled"
            return

      else 
          # Install third party repo 
          universalExtraRepos

      fi 

    ;; 

  esac 
}






## Function that handles adding RPMFusion or Pacman Repos based on if a user is on Fedora or OpenSuse 
function universalExtraRepos
{
  ## If Fedora 

  case $distroBase in 

  fedora) 
    echo "Adding BOTH RPMFusion Free and Non-Free Repos"
  
    $install https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm
    ;;

  ## If OpenSuse ... ? how to handle Gecko Linux 
  opensuse) packmanSuseRepo ;; 

  

  esac 



  ## May be redundent ... 
  ## Refresh repos 

  $refresh
}
