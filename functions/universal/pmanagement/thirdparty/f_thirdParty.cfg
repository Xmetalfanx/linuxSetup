
## This entire function is for testing only 
function stripFileInfoTestOutput
{
 
  clear
  # Display Test for the full URL
  echo -e "\n\nFull URL is:\t $packageURL"
  ###########################################


  # Display Test for Total file Extension
  echo -e "\nTotal Filename is:\t $filenameWEXT"
  ###############################################


  ## Display Test for final output
  echo -e "Final Extension for test loop:\t $extfinal"


  echo -e "Filename by itself: \t $file"
  ###########################################
}
###########################################################
###########################################################


## Gets info from URL to be used later 
function stripFileInfo
{
  
  # $1 is a URL 
  # DO I REALLY need to assign this to another variable? 
  packageURL=$1

  # Filename with extension 
  filenameWEXT=${packageURL##*/}

  ####################################
  # Old way of doing it 

  # Filename by itself, NO extention 
  filename=${filenameWEXT%%.*}

  extonly=${filenameWEXT#*.}
  ######################################


  # Call to test output function 
  # This will be removed later 
  # stripFileInfoTestOutput
  
}

###############################################################################

## This is should be what is called from program functions 
function downloadFile
{

    # This has to have the stripFileInfo function run first
    ## NOW the $packageName should be known 

    echo -e "Downloading $1 package"
    if [ "$extonly" == 'git' ]; then
        
        #idea: remove this and pass this to a git function instead 
        git clone $1

    elif [ "$extonly" == 'deb' ]; then
      # filler 
      printf "DEB stuff done here "
      
      ## I need to know the name of the full file WITH ext, for the dpkg -i line 
      
      # sudo dpkg -i
    
    elif [ "$extonly" == 'rpm' ]; then
      printf "RPM stuff done here "


    ## remember to say strip tar.gz down to targz/tgz and tar.bz2 to tarbz2 
    elif [ "$extonly" == 'targz' ] ||  [ "$extonly" == 'tgz' ] ||  [ "$extonly" == 'tarbz2' ]; then
        echo "tarball stuff done here "

        ## I think passing to an external function may be better here to keep code cleaner

    else

        # march 2019 - what is the point of this if its not a DEB, RPM, or any tarball? ... seriously I dont get what I was going for here 

        ## remember $2 is the url 
        wget -O $packageName $2
        echo "$1 downloaded"
        
    fi

    # Needed? ... I will leave it for now
    userPrompt
}

###############################################################################################

function extractDownload
{
  echo -e "About to Extract $programName's archive "

    ## What gets passed SHOULD BE the entire file name WITH ext info, but due to other functions running before this .. extfinal should be KNOWN 

    # I SHOULD have it make a temp location before extracting so the extracted downloads are organized in one place and not say ... in the root dir of these scripts 

    ## I think i may have change the varname extfinal to "extonly"... ??? 

    if [ "$extfinal" == 'targz' ] || [ "$extfinal" == 'tgz' ]; then
         tar -zxvf $1

    elif [ "$extfinal" == 'tar' ]; then
         tar -xvf $1

    elif [ "$extfinal" == 'tarxz' ]; then
        ## This echo is a "note to self" i think
        echo "Get code for this tarxz archive type"

    ## Double Check the ext on this one
    elif [ "$extfinal" == 'tarbz' ]; then
       tar -xJf $1

    elif [ "$extfinal" == 'zip' ]; then
        # unzips to the user's Downloads folder s
        unzip $1  -d ~/Downloads

    fi
  

  echo -e "$programName archive extracted"
  
  userPrompt
  
  clear

}


## I have no idea if this is a duplicate function ... I may have this elsewhere 
function installDEBRPM
{
   

    if [ "$extfinal" == 'deb' ]; then
        sudo dpkg -i $2 
        
    elif [ "$extfinal" == 'rpm' ]; then
        sudo rpm -i $2
    else 
        echo -e "$1 not installed"
    fi 
  
    echo -e "$1 has been successfully installed"
}


##################################################################
#################################################################

## Meta Function 
function externalDownload
{
  # Get Info to be used later 
    # $1 = Program Name (var)
    # $2 = URL (var)

    # Get info from the URL 
    stripFileInfo $2 


}


#################################################################
# Start of Universal third party repo section

## RPM Fusion for Fedora 
## Packman for OpenSuse 


function packmanSuseRepo
{
	echo -e "Installing Packman Repo "

	repoName="Pacman Repository"

	echo "Adding Packman Repo for added Software"


		if [ "$openSUSEVersion" == 'leap423' ]; then
			## If Leap 42.3
			packmanURL=http://ftp.gwdg.de/pub/linux/packman/suse/openSUSE_Leap_42.3/

		elif [ "$openSUSEVersion" == 'leap15' ]; then
		
			packmanURL=http://ftp.gwdg.de/pub/linux/misc/packman/suse/openSUSE_Leap_15.0/

		elif [ "$openSUSEVersion" == 'Tumbleweed' ]; then
			## If Tumbleweed
			packmanURL=http://ftp.gwdg.de/pub/linux/misc/packman/suse/openSUSE_Tumbleweed/

		else
			echo "Version can not be determined"
		fi
	
	## OUTSIDE OF IF Statement(s?)
	sudo zypper ar $repoName $packmanURL

}

## End Pacman Repo Function 
##############################################################


## Function that handles adding RPMFusion or Pacman Repos based on if a user is on Fedora or OpenSuse 
function universalThirdPartyAdditionalRepos
{
  ## If Fedora 
  if [ "$distroBase" = "fedora" ]; then

      # Add RPM Fusion repos with rpm -E %fedora .... this should work on any version
      echo "Adding BOTH RPMFusion Free and Non-Free Repos"
      userPrompt

      rpmFusionSource="https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm"

      echo -e "Setting up RPM Fusion repos"
      # TODO 

  ## If OpenSuse ... ? how to handle Gecko Linux 
  elif [ "$distroBase" = "opensuse" ]; then
    packmanSuseRepo

  fi 

  ## May be redundent ... 
  ## Refresh repos 

  $refresh
}