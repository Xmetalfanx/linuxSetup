

###################################################################################
## Gdebi related

# this should get a URL passed to it
function gdebiInstall() {

    # checks for gdebi and installs it if needed
    clear
    fancy_message action "Checking for Gdebi for the install"
    installApp "gdebi"
    userPrompt

	# only downloads the DEB if not already downloaded
		# i can see an issue with broken downloads (say "foobar.deb" is downloaded but is 0 bytes... not sure how i can check that vs the known file sie )
    if [ ! -f ${downloadedProgramFile} ]; then
		fancy_message action "Downloading ${programTitle} DEB file"
		wget -P ${downloadDir} ${programURL}
    	#debugging prompt
		userPrompt
	else
		echo "${programTitle} DEB already downloaded"
	fi


    fancy_message action "Installing ${programTitle}"
    sudo gdebi ${downloadedProgramFile}

    userPrompt

    # idea to clear the var
    # why is this here? ...
    ## it maybe needed here but i just dont remember why i put it here specifically
    packageName=/dev/null

}
## End Gdebi related
###################################################################################



###############################################################
# Test Output Functions
function stripFileInfoTestOutput() {
	clear
	# Display Test for the full URL
	echo -e "\n\nFull URL is:\t $programURL"
	# Display Test for Total file Extension
	echo -e "fileNameWEXT is:\t $fileNameWEXT"
	echo
	###############################################

	## Display Test for final output
	echo -e "fileNameFullNoDots: $fileNameFullNoDots"

	echo -e "extonly:\t $extonly"
	###########################################

	userPrompt
}





function fileExtOutput() {
	#####################################
	clear
	echo -e "completeExt3: $completeExt3"
	echo -e "completeExt6: $completeExt6"

	# only for appImage
	echo -e "completeExt8 : $completeExt8"

	userPrompt
	######################################

}

# End of Test Output functions
###############################################################################


# The reason this function is so complicated is so it handles DEBs, RPMs AND various "Tarballs" all with not only different extentions but different lengths of said-extension
function stripFileInfo() {
	fileNameWEXT=$(basename ${programURL} )

	# this say could be an AppImage or a tar.gz file (just examples)
	downloadedFile="${downloadDir}/${fileNameWEXT}"

	#fileNameWEXT with .'s stripped out
	fileNameFullNoDots=$(echo -e ${fileNameWEXT} | tr -d \.)

	## These numbers are not right for my stripped test .. the number counts the .'s
	completeExt3=${fileNameFullNoDots:(-3)}
	completeExt5=${fileNameFullNoDots:(-5)}
	completeExt6=${fileNameFullNoDots:(-6)}
	completeExt8=${fileNameFullNoDots:(-8)}

	#fileExtOutput

	if  [ "$completeExt5" = "targz" ] || \
		[ "$completeExt5" = "tarxz" ]; then

		extonly=$completeExt5

	elif [ "$completeExt6" = "tarbz2" ]; then
		extonly=$completeExt6

	elif [ "$completeExt8" = "AppImage" ]; then
		extonly=$completeExt8

	elif  [ "$completeExt3" = "deb" ] || \
			[ "$completeExt3" = "rpm" ] || \
			[ "$completeExt3" = "zip" ] || \
			[ "$completeExt3" = "tgz" ]; then

		extonly=$completeExt3

	else
		fancy_message error "Detecting file extension of file to download"
	fi
}

function downloadFile() {

    # note to self: DEBs or RPM's wouldn't make it here.  Nov 2022: what controls that though?
	# RPMs too? ... but the following step (HandleDownloaded) needs a RPM ..what did i do 

    # IF the file ALREADY exists, nothing should be done ...
    # meaning dont download the file again
    if [ -f "${downloadedProgramFile}" ]; then
		fancy_message info "File ${downloadedProgramFile}, already downloaded"
		userPrompt
    else
        case $extonly in
        	git)
            	# note to self: this here is for .git downloads only ... 
				# do not confuse this with extensions below downloaded FROM github 
				git clone ${programURL}
				;;

          rpm|targz|tgz|tarbz2|zip|AppImage)
              userPrompt
              fancy_message action "Downloading ${programTitle}"
              wget -P ${downloadDir} ${programURL}

              fancy_message info "${fileNameWEXT} downloaded "

              ;;

        esac
    fi
}

function cleanupDownloadedFile() {
    fancy_message action "Cleaning up Downloaded File"
    rm ${$downloadedFile}
}

# handles downloaded files after downloaded 
function handleDownloaded() {

	fancy_message action "\nExtracting/Installing $fileNameWEXT"

	# check for extracted download dir
	case $extonly in
		tar|tarbz2|targz|tarxz|tgz)
			fancy_message action "Checking for $extractedDownloadDir directory"
			
			if [ ! -d "$extractedDownloadDir" ]; then
				fancy_message info "Making Directory $extractedDownloadDir" && mkdir $extractedDownloadDir
			else
				fancy_message info "Directory $extractedDownloadDir already exists"
			fi
	esac

	# dec 2022: can the tar cases below somehow be combined ?
  	case $extonly in
    	deb)
		# i need to pass a URL to gdebiInstall
		gdebiInstall "${programURL}"
		;;
		rpm) $install "${downloadedProgramFile}"
		;;
		tarbz2) tar -jxvf ${$downloadedFile} -C "$extractedDownloadDir" ;;
		targz|tgz) tar -zxvf ${$downloadedFile} -C "$extractedDownloadDir" ;;
		tar) tar -xvf ${$downloadedFile} -C "$extractedDownloadDir" ;;
		tarxz) tar -xf ${$downloadedFile} -C "$extractedDownloadDir" ;;
		zip) unzip ${$downloadedFile} -d "$programName" ;;

		AppImage)

			# Lets user decide if they want to set it as executable
			appImageExecutable ${downloadedFile} 
			
			# this moves the AppImage to ~/Program/$programTitle and adds it to the user's menus 
			setupExtractedApps
			;;

		*)
			fancy_message info "Problem extracting/installing ${programTitle} "
			userPrompt ;;

	esac

	userPrompt

	#cleanupDownloadedFile

}


##################################################################
# Meta Function
# takes ${programTitle} ${programURL} (in that order) as arguments


# i think i SHOULDN'T pass debs directly to gdebiInstall but to here instead ... at the top of this function it
# should sort out DEB and RPM files
function metaExternalDownload() {

	programBasename=$(basename "${programURL}")

	# Get info from the URL
	stripFileInfo ${programURL}

	# this needs to be here (not in f_variables) since $fileNameWEXT is not known there
	downloadedProgramFile="${downloadDir}/${fileNameWEXT}"

	# if the extension is DEB or RPM (where is the RPM code?)
	# idea: this here so i can still get the info via the URL in the stripFileInfo function
	case $extonly in
		deb)
			# getdebiInstall - A) checks for and installs (what if someone just wants to use dpkg -i? ... am i not K I S S here thinking of that?) gdebi, B) downloads the DEB file, C) uses gdebi to install said file (I think i choose gdebi since dpkg doesn't handle dependencies as good, ... I swear it was something like )
			gdebiInstall ${programURL}
			# where does this return to? if just say outside of this case statement below, then downloadFile and the rest run for no reason and i dont want that 
			return ;;
	esac

	# output fuction to show what stripFileInfo found
		# used for debugging and should be commented out by default 
	#stripFileInfoTestOutput

	## Download file to ~/Downloads
		# in theory, DEB files wouldn't get here 
	downloadFile ${programName} ${programURL}

	## Handle downloaded file
		## Extract if an archive
	handleDownloaded $extonly $fileNameWEXT

	# cleanup code (removing archive file or say RPM or DEB) should be here 

}

# from deb-apt ( https://github.com/wimpysworld/deb-get )
# credit for this goes to them
# this should help me get some URLs like on Sourceforge, I beleive
# this should take a URL as an arguement 
function unpackURL() {

  # -w: Make curl display information on stdout after a completed transfer.
  # -I: Fetch the headers only
  # -L: (HTTP) If the server reports that the requested page has moved to a different location
    # (indicated with a Location: header and a 3XX response code), this option will make curl redo the
    # request on the new place.
  # -s: Silent or quiet mode. Don't show progress meter or error messages.  Makes Curl mute
  # -S: When used with -s, --silent, it makes curl show an error message if it fails.

  #clear
  #echo -e "debugging\n\nUnpacking URL "
  curl -w "%{url_effective}\n" -I -L -s "${1}" -o /dev/null
}