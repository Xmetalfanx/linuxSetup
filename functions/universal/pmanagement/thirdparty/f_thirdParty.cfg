## This entire function is for testing only
function stripFileInfoTestOutput
{

  clear
  # Display Test for the full URL
  echo -e "\n\nFull URL is:\t $packageURL"
  ###########################################


  # Display Test for Total file Extension
  echo -e "\nTotal fileName is:\t $fileNameWEXT"
  echo -e
  ###############################################


  ## Display Test for final output
  echo -e "Final Extension for test loop"
  echo -e "extonly:\t $extonly"
  echo -e
  echo -e "extTest: $extTest"

  echo -e "fileName by itself: \t $fileName"
  ###########################################

  userPrompt
}
###########################################################

function fileExtOutput()
{
  #####################################
  clear
  echo -e "completeExt3: $completeExt3"
  echo -e "completeExt6: $completeExt6"

  # only for appImage
  echo -e "completeExt8 : $completeExt8"

  userPrompt
  ######################################

}


# The reason this function is so complicated is so it handles DEBs, RPMs AND various "Tarballs" all with not only different extentions but different lengths of said-extension 
function stripFileInfo()
{
    ########################################################################
    # Debugging code only
    #echo  -e "In stripFileInfo function "
    #echo "progName: $progName"
    #echo "packageURL: $packageURL"
    #userPrompt
    ########################################################################

  # fileName with extension
  ## Idea: "match longest match to anything up to the / (which / ?.... )"
  fileNameWEXT=${packageURL##*/}

  # fileName by itself, NO extention
  ## "the longest match until there is a period".... so this will match untiL THE FINAL period it finds
  fileName=${fileNameWEXT%%.*}

  #fileNameWEXT with .'s stripped out
  extTest=$(echo $fileNameWEXT | tr -d \.)

  ## These numbers are not right for my stripped test .. the number counts the .'s 
  completeExt3=${extTest:(-3)}
  completeExt5=${extTest:(-5)}
  completeExt6=${extTest:(-6)}
  completeExt8=${extTest:(-8)}

  #fileExtOutput

  if  [ "$completeExt5" = "targz" ] || \
      [ "$completeExt5" = "tarxz" ]; then

      extonly=$completeExt5

  elif [ "$completeExt6" = "tarbz2" ]; then
      extonly=$completeExt6

  elif [ "$completeExt8" = "AppImage" ]; then
      extonly=$completeExt8

  elif  [ "$completeExt3" = "deb" ] || \
        [ "$completeExt3" = "rpm" ] || \
        [ "$completeExt3" = "zip" ] || \
        [ "$completeExt3" = "tgz" ]; then

      extonly=$completeExt3

  else
    echo -e "error detecting file extension of file to download"

  fi

  ######################################
  # Call to test output function
  # This will be removed later
  # stripFileInfoTestOutput
  ########################################

}

###############################################################################

## IF the file ALREADY exists, nothing should be done ... or at least that is the idea 
function downloadFile()
{
    # change the pwd (present working directory)
    cd ~/Downloads

    # Make Directory
    #mkdir $fileName

    # Enter Directory
    #cd $fileName

    if [ -f $fileNameWEXT ]; then

      # Do nothing, since file is already downloaded
      echo -e "File $fileNameWEXT, already downloaded"
      return

    else

        case $extonly in

        git)
            #idea: remove this and pass this to a git function instead
            git clone $packageURL
            ;;

        targz|tgz|tarbz2|deb|rpm|zip|AppImage)

            wget $packageURL

            echo $fileNameWEXT " downloaded "

            ;;
        esac

    fi

}

###############################################################################################

function handleDownloadedOutputTest()
{
  ###############################################
  echo -e "In handleDownloaded"
  echo "fileNameWEXT: $fileNameWEXT"
  userPrompt
  ##################################################

}


function handleDownloaded()
{
    clear

    #handleDownloadedOutputTest

    echo -e "Extracting/Installing $fileNameWEXT"

    case $extonly in

      deb) sudo dpkg -i $fileNameWEXT ;;

      rpm) $install $fileNameWEXT ;;

      tarbz2) tar -xvf $fileNameWEXT --one-top-level ;;

      targz|tgz)
        # I SHOULD have it make a temp location before extracting so the extracted downloads are organized in one place and not say ... in the root dir of these scripts
        tar -zxvf $fileNameWEXT --one-top-level

        # Commented out since this is not coded yet anyway 
        # customMenuItemMenu

        ;;

      tar) tar -xvf $fileNameWEXT --one-top-level;;

      tarxz)
          ## This echo is a "note to self" i think
          tar -xf $fileNameWEXT --one-top-level ;;

      zip)
        # unzips to the user's Downloads folder
        # idea: unzip $1 to LOCATION $1
        unzip $fileNameWEXT -d $fileName ;;

      AppImage)
        
        # Lets user decide if they want to set it as executable 
        appImageExecutable $fileNameWEXT ;;

      *)
          echo -e "Problem extracting/installing $1 "
          userPrompt ;;

    esac

}


##################################################################


## Meta Function
function metaExternalDownload()
{
 
    supportStatusDetection

    # Get info from the URL
    stripFileInfo $packageURL

    ## Download file to ~/Downloads
    downloadFile $progName $packageURL

    ## Handle downloaded file
      ## Extract if an archive
      ## install if DEB or RPM

    handleDownloaded $extonly $fileNameWEXT

}

