export type UnistNode = import('unist').Node
export type MdastRoot = import('mdast').Root
export type MdastNode = import('mdast').Content
export type MdastParent = import('mdast').Parent
export type MdastListContent = import('mdast').ListContent
export type MdastPhrasingContent = import('mdast').PhrasingContent
export type MdastDefinitionContent = import('mdast').DefinitionContent
export type MdastBlockContent = import('mdast').BlockContent
export type MdastTableContent = import('mdast').TableContent
export type MdastRowContent = import('mdast').RowContent
export type Parent = import('hast').Parent
export type Root = import('hast').Root
export type Element = import('hast').Element
export type Text = import('hast').Text
export type Comment = import('hast').Comment
export type ElementChild = Element['children'][number]
export type Child = Parent['children'][number]
export type Node = Child | Root
export type Handle = (
  h: H,
  node: any,
  parent?: Parent
) => MdastNode | Array<MdastNode> | void
export type Properties = Record<string, unknown>
/**
 * Configuration (optional).
 */
export type Options = {
  /**
   * Keep line endings when collapsing whitespace.
   * The default collapses to a single space.
   */
  newlines?: boolean | undefined
  /**
   * Value to use for a checked checkbox or radio input.
   */
  checked?: string | undefined
  /**
   * Value to use for an unchecked checkbox or radio input.
   */
  unchecked?: string | undefined
  /**
   * List of quotes to use.
   * Each value can be one or two characters.
   * When two, the first character determines the opening quote and the second
   * the closing quote at that level.
   * When one, both the opening and closing quote are that character.
   * The order in which the preferred quotes appear determines which quotes to
   * use at which level of nesting.
   * So, to prefer `‘’` at the first level of nesting, and `“”` at the second,
   * pass `['‘’', '“”']`.
   * If `<q>`s are nested deeper than the given amount of quotes, the markers
   * wrap around: a third level of nesting when using `['«»', '‹›']` should
   * have double guillemets, a fourth single, a fifth double again, etc.
   */
  quotes?: string[] | undefined
  /**
   * Whether the given tree represents a complete document.
   * Applies when the `tree` is a `root` node.
   * When the tree represents a complete document, then things are wrapped in
   * paragraphs when needed, and otherwise they’re left as-is.
   * The default checks for whether there’s mixed content: some phrasing nodes
   * *and* some non-phrasing nodes.
   */
  document?: boolean | undefined
  /**
   * Object mapping tag names or node types to functions handling the
   * corresponding nodes.
   * See `handlers/` for examples.
   *
   * In a handler, you have access to `h`, which should be used to create mdast
   * nodes from hast nodes.
   * On `h`, there are several fields that may be of interest.
   * Most interesting of them is `h.wrapText`, which is `true` if the mdast
   * content can include newlines, and `false` if not (such as in headings or
   * table cells).
   */
  handlers?: Record<string, Handle> | undefined
}
export type Context = {
  nodeById: Record<string, Element>
  baseFound: boolean
  frozenBaseUrl: string | null
  wrapText: boolean
  inTable: boolean
  qNesting: number
  handlers: Record<string, Handle>
  document: boolean | undefined
  checked: string
  unchecked: string
  quotes: Array<string>
}
export type HWithProps = (
  node: Node,
  type: string,
  props?: Properties,
  children?: string | Array<MdastNode>
) => MdastNode
export type HWithoutProps = (
  node: Node,
  type: string,
  children?: string | Array<MdastNode>
) => MdastNode
export type H = HWithProps & HWithoutProps & Context
