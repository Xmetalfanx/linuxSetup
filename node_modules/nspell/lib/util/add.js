'use strict'

var apply = require('./apply.js')

module.exports = add

var push = [].push

var NO_RULES = []

// Add `rules` for `word` to the table.
function addRules(dict, word, rules) {
  var curr = dict[word]

  // Some dictionaries will list the same word multiple times with different
  // rule sets.
  if (word in dict) {
    if (curr === NO_RULES) {
      dict[word] = rules.concat()
    } else {
      push.apply(curr, rules)
    }
  } else {
    dict[word] = rules.concat()
  }
}

function add(dict, word, codes, options) {
  var position = -1
  var rule
  var offset
  var subposition
  var suboffset
  var combined
  var newWords
  var otherNewWords

  // Compound words.
  if (
    !('NEEDAFFIX' in options.flags) ||
    codes.indexOf(options.flags.NEEDAFFIX) < 0
  ) {
    addRules(dict, word, codes)
  }

  while (++position < codes.length) {
    rule = options.rules[codes[position]]

    if (codes[position] in options.compoundRuleCodes) {
      options.compoundRuleCodes[codes[position]].push(word)
    }

    if (rule) {
      newWords = apply(word, rule, options.rules, [])
      offset = -1

      while (++offset < newWords.length) {
        if (!(newWords[offset] in dict)) {
          dict[newWords[offset]] = NO_RULES
        }

        if (rule.combineable) {
          subposition = position

          while (++subposition < codes.length) {
            combined = options.rules[codes[subposition]]

            if (
              combined &&
              combined.combineable &&
              rule.type !== combined.type
            ) {
              otherNewWords = apply(
                newWords[offset],
                combined,
                options.rules,
                []
              )
              suboffset = -1

              while (++suboffset < otherNewWords.length) {
                if (!(otherNewWords[suboffset] in dict)) {
                  dict[otherNewWords[suboffset]] = NO_RULES
                }
              }
            }
          }
        }
      }
    }
  }
}
